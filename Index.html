<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>A Steady Forest</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body { 
            margin: 0; padding: 0; overflow: hidden; 
            background-color: #0a0a0a; touch-action: none; 
            display: flex; justify-content: center; align-items: center;
            height: 100dvh; /* 100dvh ensures it fits perfectly inside mobile Safari/Chrome URL bars */
            width: 100vw;
        }

        #app-container {
            position: relative; 
            width: 100%; 
            height: 100%;
            background-color: #F4EFE6;
            overflow: hidden; 
            touch-action: none; user-select: none; -webkit-user-select: none;
        }

        /* If opened on a desktop/laptop, this makes it look like a physical phone screen */
        @media (min-width: 768px) {
            #app-container {
                max-width: 420px;
                height: 90vh;
                border-radius: 36px;
                box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.8), 0 0 0 12px #222; /* Fakes a phone bezel */
            }
        }
        
        canvas { display: block; width: 100%; height: 100%; outline: none; }
        
        #start-screen {
            position: absolute; inset: 0; z-index: 50;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background-color: #F4EFE6;
        }
        #ui-layer { pointer-events: none; }
        
        /* The Dark Overlay for the ending */
        #dark-overlay {
            position: absolute; inset: 0; 
            background-color: rgba(0,0,0,0.65);
            opacity: 0; pointer-events: none; z-index: 5;
        }
        
        /* Cinematic text styling */
        #main-text, #sub-text {
            color: #ffffff;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8), 0 0 5px rgba(0,0,0,0.9);
        }
        
        .fade-text { opacity: 0; transform: translateY(10px); }
        .text-shadow-heavy { text-shadow: 0 4px 15px rgba(0,0,0,0.9), 0 0 10px rgba(0,0,0,1) !important; }

        .particle {
            opacity: 0; transform: scale(0.5) translate(-50%, -50%);
            transition: transform 0.1s;
        }
        .particle:active { transform: scale(0.9) translate(-50%, -50%); }
    </style>
</head>
<body>

    <div id="app-container">
        <div id="dark-overlay"></div>

        <canvas id="webgl-canvas"></canvas>

        <div id="start-screen">
            <h1 class="text-3xl font-light text-stone-700 mb-2 tracking-wide text-center px-4" style="text-shadow: none; color: #444;">A Steady Forest</h1>
            <p class="text-sm text-stone-500 mb-12 tracking-widest uppercase text-center px-4" style="text-shadow: none;">A Thank You</p>
            
            <button id="start-btn" class="flex items-center justify-center w-16 h-16 bg-[#5A6B7C] text-white rounded-full shadow-xl active:scale-95 transition-transform cursor-pointer pointer-events-auto">
                <svg viewBox="0 0 24 24" fill="currentColor" class="w-8 h-8 ml-1"><path d="M5 3v18l15-9L5 3z"/></svg>
            </button>
        </div>

        <div id="ui-layer" class="absolute inset-0 flex flex-col items-center justify-start pt-20 px-6 text-center z-10">
            <h1 id="main-text" class="text-2xl font-light tracking-wide leading-relaxed fade-text"></h1>
            <p id="sub-text" class="text-sm font-semibold mt-3 tracking-widest uppercase fade-text"></p>
        </div>

        <div id="particle-layer" class="absolute inset-0 z-20 pointer-events-none"></div>
    </div>

<script>
    // --- 1. SETUP & RESIZE ---
    const container = document.getElementById('app-container');
    const canvas = document.getElementById('webgl-canvas');

    const scene = new THREE.Scene();
    const morningColor = new THREE.Color(0xF4EFE6);
    const stormColor = new THREE.Color(0x5A6B7C); 
    
    scene.background = morningColor;
    scene.fog = new THREE.Fog(morningColor, 15, 55); 

    const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
    camera.position.set(0, 10, 26);
    camera.lookAt(0, 3, 0);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    function resize() {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    }
    window.addEventListener('resize', resize); resize();

    // --- 2. GAME STATE ---
    let state = 0; 
    let isDragging = false;
    const memories = ["Patience", "Guidance", "Trust", "Vision", "Teamwork"]; 
    let activeMemories = 0;
    
    const mainText = document.getElementById('main-text');
    const subText = document.getElementById('sub-text');
    const particleLayer = document.getElementById('particle-layer');

    // --- 3. LIGHTING ---
    const ambientLight = new THREE.HemisphereLight(0xffffff, 0xbfd4d2, 0.7);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xfff5e6, 0.85);
    dirLight.position.set(8, 15, 10);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024; dirLight.shadow.mapSize.height = 1024;
    dirLight.shadow.camera.near = 0.5; dirLight.shadow.camera.far = 80;
    dirLight.shadow.camera.left = -30; dirLight.shadow.camera.right = 30;
    scene.add(dirLight);

    // --- 4. ENVIRONMENT ---
    const sceneParams = { windIntensity: 0 }; 

    const rainCanvas = document.createElement('canvas');
    rainCanvas.width = 4; rainCanvas.height = 32;
    const rctx = rainCanvas.getContext('2d');
    rctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    rctx.fillRect(1, 0, 2, 32); 
    const rainTex = new THREE.CanvasTexture(rainCanvas);

    const rainCount = 700;
    const rainGeo = new THREE.BufferGeometry();
    const rainPos = new Float32Array(rainCount * 6); 
    const slantX = 0.8, slantY = -2.0;

    for(let i=0; i<rainCount; i++) {
        const x = (Math.random() - 0.5) * 50; const y = Math.random() * 30; const z = (Math.random() - 0.5) * 30;
        rainPos[i*6] = x; rainPos[i*6+1] = y; rainPos[i*6+2] = z;
        rainPos[i*6+3] = x + slantX; rainPos[i*6+4] = y + slantY; rainPos[i*6+5] = z;
    }
    rainGeo.setAttribute('position', new THREE.BufferAttribute(rainPos, 3));
    const rainMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0 });
    const rainSystem = new THREE.LineSegments(rainGeo, rainMat);
    rainSystem.visible = false; 
    scene.add(rainSystem);

    const birds = [];
    const birdGroup = new THREE.Group();
    scene.add(birdGroup);

    const flareCanvas = document.createElement('canvas');
    flareCanvas.width = 256; flareCanvas.height = 256;
    const fctx = flareCanvas.getContext('2d');
    const grad = fctx.createRadialGradient(128,128,0, 128,128,128);
    grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
    grad.addColorStop(0.1, 'rgba(255, 240, 180, 0.8)');
    grad.addColorStop(0.4, 'rgba(255, 210, 120, 0.3)');
    grad.addColorStop(1, 'rgba(255, 200, 100, 0)');
    fctx.fillStyle = grad; fctx.fillRect(0,0,256,256);
    const flareMat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(flareCanvas), transparent: true, blending: THREE.AdditiveBlending, opacity: 0, depthWrite: false });
    const sunFlare = new THREE.Sprite(flareMat);
    sunFlare.position.set(12, 18, -15); 
    sunFlare.scale.set(30, 30, 1);
    scene.add(sunFlare);

    // --- 5. 3D OBJECTS ---
    const groundMat = new THREE.MeshStandardMaterial({ color: 0xDECCA6, roughness: 1 });
    const ground = new THREE.Mesh(new THREE.CylinderGeometry(60, 60, 1, 32), groundMat);
    ground.position.y = -0.5; ground.receiveShadow = true; scene.add(ground);

    function addFlowers(group, canopy, size, matArray, startOpacity) {
        if(Math.random() > 0.07) return; 
        const colors = [0xFFB7B2, 0xFFDAC1, 0xE2F0CB, 0xFF9AA2]; 
        const color = colors[Math.floor(Math.random() * colors.length)];
        const fMat = new THREE.MeshStandardMaterial({ color, flatShading: true, transparent: true, opacity: startOpacity });
        matArray.push(fMat);
        for(let i=0; i<4; i++) {
            const f = new THREE.Mesh(new THREE.IcosahedronGeometry(size*0.18, 0), fMat);
            const theta = Math.random() * Math.PI*2; const phi = Math.random() * Math.PI*0.7; 
            const r = size * 0.95;
            f.position.set(canopy.position.x + r*Math.sin(phi)*Math.cos(theta), canopy.position.y + r*Math.cos(phi), canopy.position.z + r*Math.sin(phi)*Math.sin(theta));
            f.castShadow = true; group.add(f);
        }
    }

    function createSimpleTree(color, height, size) {
        const group = new THREE.Group();
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, height, 6), new THREE.MeshStandardMaterial({ color: 0x6e5c47, flatShading: true }));
        trunk.position.y = height / 2; trunk.castShadow = true; trunk.receiveShadow = true; group.add(trunk);
        const leaves = new THREE.Mesh(new THREE.IcosahedronGeometry(size, 0), new THREE.MeshStandardMaterial({ color: color, flatShading: true }));
        leaves.position.y = height + (size * 0.4); leaves.castShadow = true;
        group.userData.leaves = [leaves]; group.add(leaves);
        return group;
    }

    function createForestTree(color, height, size) {
        const group = new THREE.Group();
        group.userData.materials = []; 
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4d3c, flatShading: true, transparent: true, opacity: 0 });
        const leafMat = new THREE.MeshStandardMaterial({ color: color, flatShading: true, transparent: true, opacity: 0 });
        group.userData.materials.push(trunkMat, leafMat);
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, height, 6), trunkMat);
        trunk.position.y = height / 2; trunk.castShadow = true; trunk.receiveShadow = true; group.add(trunk);
        const leaves = new THREE.Mesh(new THREE.IcosahedronGeometry(size, 0), leafMat);
        leaves.position.y = height + (size * 0.4); leaves.castShadow = true; group.add(leaves);
        addFlowers(group, leaves, size, group.userData.materials, 0);

        if (Math.random() > 0.5) {
            const side = Math.random() > 0.5 ? 1 : -1; 
            const bMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, height * 0.6, 6), trunkMat);
            bMesh.position.set(side * 0.6, height * 0.6, 0); bMesh.rotation.z = side * -Math.PI / 6; group.add(bMesh);
            const lMesh = new THREE.Mesh(new THREE.IcosahedronGeometry(size * 0.75, 0), leafMat);
            lMesh.position.set(side * 1.2, height * 0.9, 0); lMesh.castShadow = true; group.add(lMesh);
            addFlowers(group, lMesh, size * 0.75, group.userData.materials, 0);
        }
        return group;
    }

    function createBossTree() {
        const group = new THREE.Group();
        group.userData.leaves = [];
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4d3c, flatShading: true, transparent: true, opacity: 1 });
        const leafMat = new THREE.MeshStandardMaterial({ color: 0xb565a7, flatShading: true, transparent: true, opacity: 1 });
        group.userData.materials = [trunkMat, leafMat];
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.9, 1.4, 7.5, 7), trunkMat);
        trunk.position.y = 3.75; trunk.castShadow = true; trunk.receiveShadow = true; group.add(trunk);

        function addBranch(x, y, z, rotZ, size, reachX, reachY) {
            const bMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.7, 3.5, 6), trunkMat);
            bMesh.position.set(x, y, z); bMesh.rotation.z = rotZ; bMesh.castShadow = true; bMesh.receiveShadow = true; group.add(bMesh);
            const lMesh = new THREE.Mesh(new THREE.IcosahedronGeometry(size, 0), leafMat);
            lMesh.position.set(x + reachX, y + reachY, z); lMesh.castShadow = true; group.add(lMesh); group.userData.leaves.push(lMesh);
        }
        const centerLeaf = new THREE.Mesh(new THREE.IcosahedronGeometry(4.0, 0), leafMat);
        centerLeaf.position.set(0, 8.5, 0); centerLeaf.castShadow = true; group.add(centerLeaf); group.userData.leaves.push(centerLeaf);
        addBranch(-1.2, 5.0, 0.5, Math.PI / 5, 3.0, -2.0, 1.8);
        addBranch(1.5, 4.5, -0.5, -Math.PI / 4, 3.2, 2.2, 1.5);
        return group;
    }

    const bossTree = createBossTree();
    bossTree.position.set(2.5, 0, 0); 
    scene.add(bossTree);

    const saplingPivot = new THREE.Group();
    saplingPivot.position.set(-4, -5, 0); 
    
    const sapling = createSimpleTree(0x8CA86E, 4, 2.5);
    sapling.scale.set(0.15, 0.15, 0.15); 
    saplingPivot.add(sapling);
    scene.add(saplingPivot);

    // --- 6. ANIMATION LOOP ---
    const clock = new THREE.Clock();
    function animate() {
        requestAnimationFrame(animate);
        const t = clock.getElapsedTime();

        if (rainSystem.visible) {
            const pos = rainGeo.attributes.position.array;
            for(let i=0; i<rainCount; i++) {
                pos[i*6] += 0.2 + (sceneParams.windIntensity * 0.3); pos[i*6+1] -= 0.8; 
                pos[i*6+3] += 0.2 + (sceneParams.windIntensity * 0.3); pos[i*6+4] -= 0.8; 
                if (pos[i*6+1] < -2) {
                    const nx = (Math.random() - 0.5) * 50; const ny = 25 + Math.random() * 10; const nz = (Math.random() - 0.5) * 30;
                    pos[i*6] = nx; pos[i*6+1] = ny; pos[i*6+2] = nz;
                    pos[i*6+3] = nx + slantX; pos[i*6+4] = ny + slantY; pos[i*6+5] = nz;
                }
            }
            rainGeo.attributes.position.needsUpdate = true;
        }

        const wind = sceneParams.windIntensity;
        bossTree.rotation.z = Math.sin(t) * 0.01 * wind;
        bossTree.userData.leaves.forEach((leaf, idx) => { leaf.rotation.y = Math.sin(t * 0.5 + idx) * (0.05 + wind * 0.02); });

        const bendResistance = Math.max(0.15, 1.0 - sapling.scale.x); 
        const maxBend = 0.8 * bendResistance; 
        const smoothJitter = (Math.sin(t * 4) + Math.cos(t * 6.5)) * 0.05 * wind * bendResistance;
        saplingPivot.rotation.z = -(maxBend * wind) - smoothJitter; 
        sapling.userData.leaves[0].rotation.y = Math.sin(t * 1.5) * (0.1 + wind * 0.1);
        sapling.userData.leaves[0].rotation.z = Math.sin(t * 2) * (0.05 + wind * 0.1);

        if (state === 1 && isDragging) {
            const distance = bossTree.position.x - saplingPivot.position.x;
            sceneParams.windIntensity = Math.max(0, Math.min(1, (distance - 4.0) / 3.0)); 
        } else if (state === 2.5) {
            sceneParams.windIntensity += (1.0 - sceneParams.windIntensity) * 0.05; 
        }

        if (birds.length > 0) {
            birds.forEach(bird => {
                bird.userData.angle -= bird.userData.speed; 
                const a = bird.userData.angle; const r = bird.userData.radius;
                bird.position.set(Math.cos(a) * r, bird.userData.baseY + Math.sin(t * bird.userData.bobSpeed) * 1.5, Math.sin(a) * r);
                const nextA = a - 0.1; bird.lookAt(Math.cos(nextA) * r, bird.position.y, Math.sin(nextA) * r);
            });
        }

        renderer.render(scene, camera);
    }
    animate();

    // --- 7. DRAG & LIGHTNING LOGIC ---
    let lightningInterval;
    function flashLightning() {
        if (state !== 2.5) { clearInterval(lightningInterval); return; }
        if (Math.random() > 0.6) {
            scene.background.setHex(0xcbd5e1); 
            dirLight.intensity = 3;
            setTimeout(() => {
                if (state === 2.5) {
                    scene.background.copy(stormColor);
                    dirLight.intensity = 0.4;
                }
            }, 50 + Math.random() * 100);
        }
    }

    function updateText(main, sub = "", color = "#ffffff", addHeavyShadow = true) { 
        gsap.to([mainText, subText], { opacity: 0, y: -10, duration: 0.5, onComplete: () => {
            mainText.innerText = main; subText.innerText = sub; mainText.style.color = color; subText.style.color = color;
            if (addHeavyShadow) { mainText.classList.add('text-shadow-heavy'); subText.classList.add('text-shadow-heavy'); } 
            else { mainText.classList.remove('text-shadow-heavy'); subText.classList.remove('text-shadow-heavy'); }
            if(main || sub) gsap.fromTo([mainText, subText], { opacity: 0, y: 10 }, { opacity: 1, y: 0, duration: 1, stagger: 0.2 });
        }});
    }

    function handlePointer(e) {
        if (state !== 1) return;
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const rect = container.getBoundingClientRect();
        let worldX = ((clientX - rect.left) / rect.width * 10) - 5; 
        worldX = Math.max(-5.5, Math.min(worldX, bossTree.position.x - 3.5));
        gsap.to(saplingPivot.position, { x: worldX, duration: 0.1, ease: "power1.out" });

        if (bossTree.position.x - worldX < 4.2) {
            state = 2; isDragging = false;
            gsap.to(saplingPivot.position, { x: -1.5, duration: 0.8, ease: "back.out(1.2)" });
            gsap.to(sapling.scale, { x: 0.25, y: 0.25, z: 0.25, duration: 1, ease: "elastic.out(1, 0.5)" });
            startPhase2();
        }
    }

    container.addEventListener('pointerdown', (e) => { if (state === 1) { isDragging = true; handlePointer(e); }});
    container.addEventListener('pointermove', (e) => { if (state === 1 && isDragging) handlePointer(e); });
    container.addEventListener('pointerup', () => isDragging = false);
    container.addEventListener('pointercancel', () => isDragging = false);

    // --- 8. STORY SEQUENCES ---
    document.getElementById('start-btn').addEventListener('click', () => {
        gsap.to(document.getElementById('start-screen'), { opacity: 0, duration: 1, onComplete: () => {
            document.getElementById('start-screen').style.display = 'none';
            startPhase1();
        }});
    });

    function startPhase1() {
        gsap.to(scene.background, { r: stormColor.r, g: stormColor.g, b: stormColor.b, duration: 2 });
        gsap.to(scene.fog.color, { r: stormColor.r, g: stormColor.g, b: stormColor.b, duration: 2 });
        gsap.to(ambientLight, { intensity: 0.3, duration: 2 }); gsap.to(dirLight, { intensity: 0.4, duration: 2 });
        rainSystem.visible = true; gsap.to(rainMat, { opacity: 0.8, duration: 2 });
        gsap.to(sceneParams, { windIntensity: 1, duration: 2 });

        updateText("When I started, I was fragile.", "(Drag the sprout to safety)"); 
        state = 1;
        gsap.fromTo(saplingPivot.position, { y: -5, x: -4.5 }, { y: 0, duration: 2, ease: "back.out(1.2)" });
    }

    function startPhase2() {
        gsap.to(sceneParams, { windIntensity: 0, duration: 1.5 }); 
        gsap.to(scene.background, { r: morningColor.r, g: morningColor.g, b: morningColor.b, duration: 3 });
        gsap.to(scene.fog.color, { r: morningColor.r, g: morningColor.g, b: morningColor.b, duration: 3 });
        gsap.to(ambientLight, { intensity: 0.7, duration: 3 }); gsap.to(dirLight, { intensity: 0.85, duration: 3 });
        gsap.to(rainMat, { opacity: 0, duration: 2, onComplete: () => { rainSystem.visible = false; }});

        updateText("You provided a safe space to grow.", "(Tap to absorb)");
        activeMemories = memories.length;

        const positions = [];
        for (let i = 0; i < memories.length; i++) {
            let safe = false; let leftPerc, topPerc; let attempts = 0;
            while (!safe && attempts < 50) {
                leftPerc = 15 + Math.random() * 70; topPerc = 25 + Math.random() * 30; safe = true;
                for (let j = 0; j < positions.length; j++) {
                    if (Math.sqrt(Math.pow(positions[j].left - leftPerc, 2) + Math.pow(positions[j].top - topPerc, 2)) < 25) { safe = false; break; }
                }
                attempts++;
            }
            positions.push({ left: leftPerc, top: topPerc });
            
            const btn = document.createElement('div');
            btn.className = "particle absolute px-5 py-2.5 bg-white/95 text-[#6e5c47] font-bold rounded-full shadow-[0_8px_16px_rgba(0,0,0,0.15)] pointer-events-auto cursor-pointer";
            btn.innerText = memories[i];
            btn.style.left = `${leftPerc}%`; btn.style.top = `${topPerc}%`;
            particleLayer.appendChild(btn);

            gsap.to(btn, { opacity: 1, scale: 1, duration: 0.5, delay: i * 0.2 + 2, ease: "back.out(1.5)" });
            gsap.to(btn, { y: "-=15", duration: 1.5 + Math.random(), repeat: -1, yoyo: true, ease: "sine.inOut" });

            btn.addEventListener('pointerdown', (e) => {
                e.stopPropagation(); gsap.killTweensOf(btn);
                const treePos3D = new THREE.Vector3(saplingPivot.position.x, 2.5, saplingPivot.position.z);
                treePos3D.project(camera); 
                const targetLeft = (treePos3D.x * 0.5 + 0.5) * 100; const targetTop = (-(treePos3D.y * 0.5) + 0.5) * 100;

                gsap.to(btn, { 
                    left: `${targetLeft}%`, top: `${targetTop}%`, scale: 0.1, opacity: 0, duration: 0.6, ease: "power2.in", 
                    onComplete: () => {
                        btn.remove();
                        const newScale = sapling.scale.x + 0.15; 
                        gsap.to(sapling.scale, { x: newScale, y: newScale, z: newScale, duration: 1.2, ease: "elastic.out(1, 0.4)" });
                        activeMemories--;
                        
                        if (activeMemories === 0) { 
                            // PRE-STORM PAUSE & SLOW ZOOM IN
                            state = 2.4;
                            updateText("", ""); 
                            
                            const startCamPos = camera.position.clone();
                            const targetCamPos = new THREE.Vector3(0.5, 6, 15); 
                            let camTween = { t: 0 };
                            
                            gsap.to(camTween, {
                                t: 1, duration: 3.5, ease: "power2.inOut",
                                onUpdate: () => {
                                    camera.position.lerpVectors(startCamPos, targetCamPos, camTween.t);
                                    camera.lookAt(0.5 * camTween.t, 3, 0); 
                                },
                                onComplete: () => {
                                    state = 2.5; 
                                    startPhase2_5(); 
                                }
                            });
                        }
                    }
                });
            });
        }
    }

    function startPhase2_5() {
        updateText("When the storms returned...", "(We didn't break)");

        gsap.to(scene.background, { r: stormColor.r, g: stormColor.g, b: stormColor.b, duration: 2 });
        gsap.to(scene.fog.color, { r: stormColor.r, g: stormColor.g, b: stormColor.b, duration: 2 });
        gsap.to(ambientLight, { intensity: 0.3, duration: 2 });
        gsap.to(dirLight, { intensity: 0.4, duration: 2 });
        
        rainSystem.visible = true;
        gsap.to(rainMat, { opacity: 1.0, duration: 2 });

        lightningInterval = setInterval(flashLightning, 300);

        setTimeout(startPhase3, 9000);
    }

    function startPhase3() {
        state = 3;
        clearInterval(lightningInterval); 

        updateText("Because of you, I learned to stand on my own.", "");

        gsap.to(sceneParams, { windIntensity: 0, duration: 3 });
        gsap.to(rainMat, { opacity: 0, duration: 2, onComplete: () => { rainSystem.visible = false; }});

        gsap.to(scene.background, { r: 235/255, g: 225/255, b: 205/255, duration: 4 });
        gsap.to(scene.fog.color, { r: 235/255, g: 225/255, b: 205/255, duration: 4 });
        gsap.to(dirLight.color, { r: 255/255, g: 220/255, b: 180/255, duration: 4 });
        gsap.to(ambientLight, { intensity: 0.7, duration: 4 });
        gsap.to(dirLight, { intensity: 1.0, duration: 4 });

        gsap.to(sunFlare.material, { opacity: 1, duration: 4 });
        gsap.to(sunFlare.scale, { x: 38, y: 38, duration: 4, yoyo: true, repeat: -1, ease: "sine.inOut" });

        gsap.to(sapling.scale, { x: 0.85, y: 0.85, z: 0.85, duration: 4, ease: "power2.inOut" });
        gsap.to(bossTree.position, { x: 6.5, duration: 4, ease: "power2.inOut" });

        // ZOOM BACK OUT TO NORMAL
        const startCamPos = camera.position.clone();
        const targetCamPos = new THREE.Vector3(0, 10, 26); 
        let camTween = { t: 0 };
        gsap.to(camTween, {
            t: 1, duration: 4, ease: "power2.inOut",
            onUpdate: () => {
                camera.position.lerpVectors(startCamPos, targetCamPos, camTween.t);
                camera.lookAt(0.5 * (1 - camTween.t), 3, 0); 
            }
        });

        setTimeout(startPhase4, 8000);
    }

    function startPhase4() {
        updateText("You may stand in another field now...", ""); 
        
        gsap.to(scene.fog, { near: 35, far: 110, duration: 8 });
        gsap.to(camera.position, { y: 22, z: 48, duration: 8, ease: "power2.inOut" });
        gsap.to(camera.rotation, { x: -0.18, duration: 8, ease: "power2.inOut" });
        
        gsap.to(sunFlare.material, { opacity: 0, duration: 4 });

        const treeColors = [0x657A53, 0x8CA86E, 0xE9C46A, 0xF4A261, 0xffb7b2];
        for (let i = 0; i < 70; i++) {
            const bgTree = createForestTree(
                treeColors[Math.floor(Math.random() * treeColors.length)], 
                2.5 + Math.random() * 4.5, 1.5 + Math.random() * 2.5
            );
            let angle = Math.random() * Math.PI * 2; let radius = 6 + Math.random() * 35; 
            bgTree.position.set(Math.cos(angle) * radius - 1.5, 0, Math.sin(angle) * radius - 5);
            bgTree.scale.set(0.01, 0.01, 0.01); scene.add(bgTree);

            const fadeDelay = 0.5 + Math.random() * 3.5; 
            bgTree.userData.materials.forEach(mat => { gsap.to(mat, { opacity: 1, duration: 3.5, delay: fadeDelay, ease: "power1.inOut" }); });
            gsap.to(bgTree.scale, { x: 1, y: 1, z: 1, duration: 3.5, delay: fadeDelay, ease: "power2.out" });
        }

        const birdGeo = new THREE.ConeGeometry(0.2, 0.8, 4); birdGeo.rotateX(Math.PI / 2); 
        for (let i = 0; i < 12; i++) {
            const birdMat = new THREE.MeshBasicMaterial({ color: 0x333333, transparent: true, opacity: 0 });
            const bird = new THREE.Mesh(birdGeo, birdMat);
            bird.userData = { angle: Math.random() * Math.PI * 2, speed: 0.0015 + Math.random() * 0.0015, radius: 10 + Math.random() * 25, baseY: 15 + Math.random() * 8, bobSpeed: 0.5 + Math.random() * 0.8 };
            birdGroup.add(bird); birds.push(bird);
            gsap.to(birdMat, { opacity: 0.7, duration: 4, delay: 5 + Math.random() * 2 });
        }

        bossTree.userData.materials.forEach(mat => { gsap.to(mat, { opacity: 0, duration: 3, ease: "power1.inOut" }); });
        gsap.to(bossTree.scale, { x: 0.01, y: 0.01, z: 0.01, duration: 3, ease: "power2.in" });

        setTimeout(() => {
            bossTree.position.set(0, 0, -35); 
            bossTree.userData.materials.forEach(mat => { gsap.to(mat, { opacity: 0.8, duration: 6, ease: "power1.inOut" }); });
            gsap.to(bossTree.scale, { x: 2.5, y: 2.5, z: 2.5, duration: 6, ease: "power2.out" });
        }, 3000);

        setTimeout(() => {
            updateText("You may stand in another field now...", "But this forest is stronger because of you.");
        }, 8500);

        // --- THE FINAL FAREWELL ---
        setTimeout(() => {
            // Fade in the dark background tint
            gsap.to('#dark-overlay', { opacity: 1, duration: 3 });
            
            // Present the final message over the darkened forest
            updateText("Good luck on your new journey!", "Until we meet again.", "#ffffff", true);
        }, 16000);
    }

</script>
</body>
</html>